package main

import (
	"fmt"
	"github.com/icewind666/html-to-excel-renderer/src/generator"
	"github.com/icewind666/html-to-excel-renderer/src/types"
	"github.com/jbowtie/gokogiri"
	"github.com/jbowtie/gokogiri/xml"
	"github.com/jbowtie/gokogiri/xpath"
	"github.com/jessevdk/go-flags"
	log "github.com/sirupsen/logrus"
	_ "image"
	_ "image/jpeg"
	_ "image/png"
	"io/ioutil"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"strings"
	"time"
)


var (
	version = "1.2.1"
	date    = "14.09.2021"
	builtBy = "v.korennoj@medpoint24.ru"
)

// XpathTable Search strings for html tags
var XpathTable = xpath.Compile(".//table")
var XpathThead = xpath.Compile(".//thead/tr")
var XpathTh = xpath.Compile(".//th")
var XpathTr = xpath.Compile("./tr")
var XpathTd = xpath.Compile(".//td")
var XpathImg = xpath.Compile(".//img")

var opts struct {
	Version bool `long:"version" description:"Show current version"`
	UseHandleBars bool `long:"handlebars" description:"Use Handlebars template engine"`
	Output string `long:"output" description:"Output xslx filepath"`
	TemplateFile string `long:"template" description:"A Handlebars template file"`
	DataFile string `long:"data" description:"A json data file. Used with handlebars rendering"`
	HtmlFile string `long:"html" description:"Html rendered source file"`
	BatchSize int `long:"batch-size" description:"Max rows for one iteration. Smaller size leads to smaller amount of memory used"`
	PxWidthToExcel float64 `long:"px-width" description:"Multiplier used to map pixels in html to width in excel"`
	PxHeightToExcel float64 `long:"px-height" description:"Multiplier used to map pixels in html to height in excel"`
	HelpersPath string `long:"helpers" description:"Path to helpers folder. Used with handlebars rendering"`
	DebugMode bool `long:"debug" description:"Enable debug mode. Default is false"`
	LogLevel string `long:"log-level" description:"Log level(info, warn, debug...). Default is info"`
}


func main() {
	log.SetOutput(os.Stdout)
	_,err := flags.Parse(&opts)

	if err != nil {
		log.WithError(err).Error("Can't parse command line arguments")
	}

	showVersion := opts.Version

	if showVersion {
		println(version)
		os.Exit(0)
	}

	log.Infof("html-to-excel-renderer v%s, built at %s by %s", version, date, builtBy)

	useHandlebars := opts.UseHandleBars
	template := opts.TemplateFile
	htmlFile := opts.HtmlFile
	data := opts.DataFile
	output := opts.Output
	debugMode := opts.DebugMode
	batchSize := opts.BatchSize

	if opts.PxWidthToExcel <= 0 {
		opts.PxWidthToExcel = 0.15 // default
	}

	if opts.PxHeightToExcel <= 0 {
		opts.PxHeightToExcel = 0.10 // default
	}

	if runtime.GOOS == "windows" && useHandlebars {
		log.Fatalf("Current version does not support using Handlebars on Windows systems! Sorry! Will be fixed in next version")
	}

	if useHandlebars && opts.HelpersPath == "" {
		log.Error("Using Handlebars without setting helpers path will likely cause errors! Hope your template does not contain helpers :)")
	} else {
		opts.HelpersPath += "/*.js"
	}

	if batchSize <= 0 {
		batchSize = 10000
	}

	logLevel,err := log.ParseLevel(opts.LogLevel)

	if err != nil {
		log.Warn("Debug level set to info (default value)")
		log.SetLevel(log.InfoLevel)
	} else {
		log.SetLevel(logLevel)
	}

	if debugMode {
		log.Infoln("Debug mode is ON (will write MUCH MORE logs!!)")
	}

	renderedHtml := ""
	defer timeTrack(time.Now(), "main")
	if useHandlebars {
		renderedHtml = applyHbsRendering(template, data, opts.HelpersPath)
		log.Infoln("Rendering Handlebars.js template to html is done")
	} else {
		renderedHtml = ReadHtmlFile(htmlFile)
		log.Infoln("Reading html is done")
	}

	generateXlsxFile(renderedHtml, output, batchSize)
	PrintMemUsage()
	log.Infoln("All done")
}


func NewHtmlStyle() *types.HtmlStyle {
	return &types.HtmlStyle {
		TextAlign:         "",
		WordWrap:          false,
		Width:             0,
		Height:            0,
		BorderInheritance: false,
		BorderStyle:       false,
		FontSize:          0,
		IsBold:            false,
		Colspan:           0,
		VerticalAlign:     "",
		CellValueType: StringValueType,
		BackgroundColor:   "",
	}
}

// ReadHtmlFile Read and return file contents as string
func ReadHtmlFile(htmlFilename string) string {
	byteValue, _ := ioutil.ReadFile(htmlFilename)
	if htmlFilename == "" {
		log.Fatalln("Html file is not specified(--html)")
	}

	if byteValue == nil {
		log.Fatalf("Html file is empty? %s", htmlFilename)
	}

	return string(byteValue)
}

func NewExcelizeGenerator() *generator.ExcelizeGenerator {
	return &generator.ExcelizeGenerator{
		OpenedFile:   nil,
		Filename:     "",
		CurrentSheet: "",
		CurrentCol:   0,
		CurrentRow:   0,
	}
}

// Parses given html and generates xslt file.
// File is generated by adding batches of batchSize to in on every iteration.
func generateXlsxFile(html string, outputFilename string, batchSize int) string {
	defer timeTrack(time.Now(), "generateXlsxFile")
	doc, err := gokogiri.ParseHtml([]byte(html))

	if err != nil {
		log.WithError(err).Fatalln("Parse html ERROR!")
	}

	tables, _ := doc.Root().Search(XpathTable)
	defer doc.Free()

	// creating excel excelizeGenerator
	excelizeGenerator := NewExcelizeGenerator()
	excelFilename := fmt.Sprintf("%s", outputFilename)
	excelizeGenerator.Filename = excelFilename
	excelizeGenerator.CurrentCol = 1
	excelizeGenerator.CurrentRow = 1
	excelizeGenerator.Create()

	totalRows := 0
	currentSheetIndex := 0

	// Main cycle through all tables in file
	for i, table := range tables {
		// Create new sheet for each table. Name it with data-name from html attribute
		sheetName := table.Attr("data-name")

		if sheetName == "" {
			sheetName = fmt.Sprintf("DataSheet %d", i)
			log.Infof("Warning! No data-name in for table found. Used %s as sheet name\n", sheetName)
		}

		if currentSheetIndex == 0 {
			excelizeGenerator.SetSheetName("Sheet1", sheetName)
		} else {
			excelizeGenerator.AddSheet(sheetName)
		}

		excelizeGenerator.CurrentCol = 1
		excelizeGenerator.CurrentRow = 0

		// Get thead for table and create header in xlsx
		theadTrs, _ := table.Search(XpathThead)
		processHtmlTheadTag(theadTrs, excelizeGenerator)

		// Get all rows in html table
		rows, _ := table.Search(XpathTr)
		rowsProceeded := 0
		packSize := batchSize

		for rowsProceeded < len(rows) {
			processTableRows(rows, excelizeGenerator, rowsProceeded, packSize)
			rowsProceeded += packSize
		}

		totalRows += len(rows) // stored only for log output
		rows = nil // just for sure. prevent memory leak which was found during tests in 3rd party lib
		currentSheetIndex += 1
	}

	excelizeGenerator.Save(excelizeGenerator.Filename)

	log.Infof("Total rows done: %d", totalRows)
	return excelFilename
}

// processTableRows Process all html table rows. Starts with <th> table headers then goes over <tr> and <td> inside them.
func processTableRows(rows []xml.Node, generator *generator.ExcelizeGenerator, offset int, rowsNumber int) {
	defer timeTrack(time.Now(), "processTableRows")
	if offset >= len(rows) {
		return // offset cant be greater than number of rows
	}

	if len(rows) < rowsNumber {
		rowsNumber = len(rows) // when less than one page
	}

	for i := offset; i <= (offset + rowsNumber - 1); i++ {
		if i >= len(rows) {
			break // we are done here
		}

		tr := rows[i]
		generator.AddRow()

		theadTrs, _ := tr.Search(XpathTh)
		generator.CurrentCol = 1

		// <th>
		for _, theadTh := range theadTrs {
			thStyle := theadTh.Attribute(StyleAttrName)
			cellValue := theadTh.Content()

			if thStyle != nil {
				style := ExtractStyles(thStyle)
				thColspan := theadTh.Attribute(ColspanAttrName)

				if thColspan != nil {
					style.Colspan,_ = strconv.Atoi(thColspan.Value())
				}

				generator.ApplyColumnStyle(style)
				generator.ApplyCellStyle(style)
			}

			// <img>
			// NOTE: is it valid to have img in th?)
			imgs, _ := theadTh.Search(XpathImg)

			if len(imgs) > 0 {
				for _, img := range imgs {
					addImageToCell(img, generator)
				}
			} else {
				if cellValue != "" {

					generator.SetCellValue(cellValue)
				}
			}

			generator.CurrentCol += 1
		}

		cells, _ := tr.Search(XpathTd)
		generator.CurrentCol = 1

		// table td cells
		for _, td := range cells {
			tdStyle := td.Attribute("style")
			cellValue := td.Content()
			cellValueType := StringValueType

			if tdStyle != nil {
				cellStyle := ExtractStyles(tdStyle)
				tdColspan := td.Attribute(ColspanAttrName)
				cellValueType = cellStyle.CellValueType
				if tdColspan != nil {
					cellStyle.Colspan,_ = strconv.Atoi(tdColspan.Value())
				}

				generator.ApplyCellStyle(cellStyle)
			}

			imgs, _ := td.Search(XpathImg)

			if len(imgs) > 0 {
				for _, img := range imgs {
					addImageToCell(img, generator)
				}
			} else {
				if cellValue != "" {
					switch cellValueType {
					case FloatValueType:
						floatContent,err := strconv.ParseFloat(cellValue, 64)

						if err != nil {
							log.WithError(err).Error("Cant parse cell type")
						}

						generator.SetCellFloatValue(floatContent)
					case BooleanValueType:
						boolContent, err := strconv.ParseBool(cellValue)

						if err != nil {
							log.WithError(err).Error("Cant parse bool value from string")
						}
						generator.SetCellBoolValue(boolContent)
					default:
						generator.SetCellValue(cellValue)
					}
				}
			}

			generator.CurrentCol += 1
		}

		trStyle := tr.Attribute("style")

		// Apply row style if present
		if trStyle != nil {
			styleExtracted := ExtractStyles(trStyle)
			generator.ApplyRowStyle(styleExtracted)
		}
	}
}

// addImageToCell Inserts image to current cell. Or its alternative text
func addImageToCell(img xml.Node, generator *generator.ExcelizeGenerator) {
	imgSrc := img.Attribute("src")
	imgAlt := img.Attribute("alt")

	// If file exist - set image to cell
	if _, err := os.Stat(imgSrc.Value()); os.IsNotExist(err) {
		if err != nil {
			log.WithError(err).Errorln("Cant access image file")
		}
		generator.SetCellValue(imgAlt.Value())
	}

	currentCellCoords, errCoords := generator.GetCoords()

	if errCoords != nil {
		log.WithError(errCoords).Errorln(errCoords)
	}

	errAdd := generator.OpenedFile.AddPicture(generator.CurrentSheet,
		currentCellCoords,
		imgSrc.Value(),
		`{"autofit":true, "lock_aspect_ratio": true, "positioning": "oneCell"}`)
	if errAdd != nil {
		log.Printf(errAdd.Error())
	}
}


// processHtmlTheadTag Process thead tag (thead->tr + thead->tr->th). Apply column styles. Apply cell styles
func processHtmlTheadTag(theadTrs []xml.Node, generator *generator.ExcelizeGenerator) {
	defer timeTrack(time.Now(), "processHtmlTheadTag")
	for _, theadTr := range theadTrs {
		generator.AddRow()
		theadTrThs, _ := theadTr.Search(XpathTh) // search for <th>
		colIndex := 1

		for _, theadTh := range theadTrThs { // for each <th> in <tr>
			thStyle := theadTh.Attribute(StyleAttrName)

			style := ExtractStyles(thStyle)
			thColspan := theadTh.Attribute(ColspanAttrName)

			if thColspan != nil {
				style.Colspan, _ = strconv.Atoi(thColspan.Value())
			}

			content := theadTh.Content()

			if content != "" {
				switch style.CellValueType {
				case FloatValueType:
					floatContent,err := strconv.ParseFloat(content, 64)

					if err != nil {
						log.WithError(err).Error("Cant parse cell type")
					}

					generator.SetCellFloatValue(floatContent)
				case BooleanValueType:
					boolContent, err := strconv.ParseBool(content)

					if err != nil {
						log.WithError(err).Error("Cant parse bool value from string")
					}
					generator.SetCellBoolValue(boolContent)
				default:
					generator.SetCellValue(content)
				}
			}

			if style != nil {
				generator.ApplyColumnStyle(style)
				generator.ApplyCellStyle(style)
			}

			colIndex++
		}

		thStyle := theadTr.Attribute(StyleAttrName)

		if thStyle != nil {
			rowStyle := ExtractStyles(thStyle)
			thColspan := thStyle.Attribute(ColspanAttrName)

			if thColspan != nil {
				rowStyle.Colspan, _ = strconv.Atoi(thColspan.Value())
			}
			if rowStyle != nil {
				generator.ApplyRowStyle(rowStyle)
			}
		}
	}
}

// applyHbsRendering Calls shell hbs-cli to process handlebars.js template
func applyHbsRendering(templateFilename string, dataFilename string, helpersPath string) string {
	defer timeTrack(time.Now(), "applyHbsRendering")
	args := []string{"--helper", helpersPath, "--data", dataFilename, templateFilename, "--stdout"}
	cmd := exec.Command("hbs", args...)
	outStr, err := cmd.Output()

	if err != nil {
		log.WithError(err).Fatal("Can't run hbs shell command!")
	}

	if opts.DebugMode {
		err := ioutil.WriteFile("./debug.html", outStr, 0777)
		if err != nil {
			log.Warn("Can't write debug html file!")
		}
	}

	return string(outStr)
}


// ExtractStyles Returns parsed style struct
func ExtractStyles(node *xml.AttributeNode) *types.HtmlStyle {
	if node == nil {
		return NewHtmlStyle()
	}

	styleStr := node.Content()
	entries := strings.Split(styleStr, ";")
	resultStyle := NewHtmlStyle()

	for _, e := range entries {
		if e != "" {
			parts := strings.Split(e, ":")

			if len(parts) < 2 {
				continue
			}

			value := strings.Trim(parts[1], " ")
			attr := strings.Trim(parts[0], " ")

			switch attr {
			case ColspanAttrName:
				resultStyle.Colspan, _ = strconv.Atoi(value)

			case TextAlignStyleAttr:
				resultStyle.TextAlign = value

			case WordWrapStyleAttr:
				resultStyle.WordWrap = value == BreakWordWrapStyleAttrValue

			case WidthStyleAttr:
				widthEntry := strings.Trim(value, " px")
				widthInt, _ := strconv.Atoi(widthEntry)
				translatedWidth := float64(widthInt) * opts.PxWidthToExcel
				resultStyle.Width = translatedWidth

			case MinWidthStyleAttr:
				if resultStyle.Width <= 0 {
					widthEntry := strings.Trim(value, " px")
					widthInt, _ := strconv.Atoi(widthEntry)
					translatedWidth := float64(widthInt) * opts.PxWidthToExcel
					resultStyle.Width = translatedWidth
				}
			case MaxWidthStyleAttr:
				if resultStyle.Width <= 0 {
					widthEntry := strings.Trim(value, " px")
					widthInt, _ := strconv.Atoi(widthEntry)
					translatedWidth := float64(widthInt) * opts.PxWidthToExcel
					resultStyle.Width = translatedWidth
				}

			case HeightStyleAttr:
				heightEntry := strings.Trim(value, " px")
				heightInt, _ := strconv.Atoi(heightEntry)
				translatedHeight := float64(heightInt) * opts.PxHeightToExcel
				resultStyle.Height = translatedHeight

			case MinHeightStyleAttr:
				if resultStyle.Height <= 0 {
					heightEntry := strings.Trim(value, " px")
					heightInt, _ := strconv.Atoi(heightEntry)
					translatedHeight := float64(heightInt) * opts.PxHeightToExcel
					resultStyle.Height = translatedHeight
				}
			case MaxHeightStyleAttr:
				if resultStyle.Height <= 0 {
					heightEntry := strings.Trim(value, " px")
					heightInt, _ := strconv.Atoi(heightEntry)
					translatedHeight := float64(heightInt) * opts.PxHeightToExcel
					resultStyle.Height = translatedHeight
				}
			case BorderStyleAttr:
				resultStyle.BorderStyle = value == BorderStyleAttrValue

			case BorderInheritanceStyleAttr:
				resultStyle.BorderStyle = value == BorderInheritanceStyleAttrValue

			case FontSizeStyleAttr:
				widthEntry := strings.Trim(value, " px")
				sz,_ := strconv.Atoi(widthEntry)
				resultStyle.FontSize = float64(sz)

			case FontWeightStyleAttr:
				resultStyle.IsBold = strings.Contains(value, "bold")

			case TextVerticalAlignStyleAttr:
				if value == "middle" {
					value = "center" // excelize lib dont understand middle :) center works fine
				}
				resultStyle.VerticalAlign = value
			case ValueTypeAttrName:
				cellType := types.ValueType(value)
				switch cellType { // filter only supported types
				case FloatValueType:
				case BooleanValueType:
					resultStyle.CellValueType = cellType
				}
			case BackgroundColorAttrName:
				resultStyle.BackgroundColor = value

			}


		}
	}
	return resultStyle
}


// PrintMemUsage outputs the current, total and OS memory being used. As well as the number
// of garage collection cycles completed.
func PrintMemUsage() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	// For info on each, see: https://golang.org/pkg/runtime/#MemStats
	log.Infof("Alloc = %v MiB, HeapAlloc = %v MiB, Sys = %v MiB", bToMb(m.Alloc),
		bToMb(m.HeapAlloc), bToMb(m.Sys))
}

// bToMb Converts bytes to human readable file size
func bToMb(b uint64) uint64 {
	return b / 1024 / 1024
}

func timeTrack(start time.Time, name string) {
	if opts.DebugMode {
		elapsed := time.Since(start)
		log.Printf("%s took %s", name, elapsed)
	}
}